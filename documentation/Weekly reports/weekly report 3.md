# Weekly Report 3 
1. What have I been up to this week? <br />
   - [x] I have implemented the JPS algorithm. I felt it took me way too long, perhaps partly because I decided to not look at any practical implementations online and instead base my entire solution on what I've read from articles and the JPS paper. I was mostly preparing myself to create a command line tool, but reading the goals for week 3 from the page, I found that graphical interface is requiered and I tried to rush it. Because my algorithm was designed to be run in the commmand line and because I haven't used Tkinter before, the process of adjusting the algorithm to run in the window was painstakingly difficult. I found that Tkinter works in unexpected ways and also that imports work differently depending on whether a file is main.py or not. So in the end I spent a lot of time debuggin the messy code and forcing it unto Tkinter rather than anything else. One of the frustrating parts was that I tried to pass a function that updates a window to the algorithm_service function, and it worked well, but when it was passed to the actual JPS algorithm, the window wouldn't update until the algorithm stopped executing. I still don't know what caused it and I put together an okay for now solution.
2. How has the program progressed? <br />
   - [x] I'm glad that at least **JPS** seems to be working so weel even though the program is obviously pretty bloated and could use more refactoring. While there is not many representative inputs in the testing yet, I think that in principle the algorithm should work reliably. I also started working with the graphical interface which had to start eventually, and apart from the hurdles I've experienced, it seems manageable. I'm taking inspiration from my projects in other courses I'm doing for university and I'm glad there is already so many shortcuts e.g. for testing branch coverage or automatic linting of the code. I think that the biggest shortcoming this week is that I haven't implemented visualization of Dijkstra and I need to get back to improving the readability of the code just to make it easier to work on.<br />
3. What did I learn this week / today? <br />
   - [x] I learnt more about imports and the graphical interface mostly. Regarding coding practices, I'm looking at how to implement pylint better in my IDE, since I'm using neovim and I haven't figured out how to integrate it with code editing. I wrote a ton of tests and I'm happy about it. Outside of that, I think I need to plan my projects better for the future so that I can deliver on time and make my code more usable for the end product. This week clearly I've postponed creating the GUI for too long and my code wasn't compatible with it at first, and it's probably a good lesson.
4. What was unclear or caused difficulties? Audn nswer this section honestly, as you will receive help based on this section if needed.  <br />
   - [x] I didn't like writing code for Tkinter and I don't think that the course material covered it enough. I looked at the links attached to the page and read up on them, but using the GUI felt pretty vapid. Especially hard for me was the question of how to make any sort of visualization of an algorithm in an interface that seems fundamentally opposed to doing anything synchronously. I thought that the fact that I need to close the window and open it again to see any effects was a waste of time, and that the graphical componenets introduced in the material were not at all modern and looked very outdated. I didn't know how to efficiently code the interface, also because all graphical elements require so much of space! I've experience react before and I know it's possible to refactor every componenent to be in it's own file and maybe that would have been better, because the growing complexity of the program was just too hard to grasp. The program also appeared unintuitive to me because there's those things like windows, roots, tk vs ttk vs Tk that i had no clue about and that didnt look logical to me at all. I understand that UI code looks so bad that it doesn't matter if it's linted or tested at all. To me, it's just unsusable and i'd rather go back to command line. Apart from that, I also hated that the structure of the program in the end wasn't clear to me. Does my project need repositories? services? I suppose it's somewhere in the course materials, but honestly navigating the algolabra page is harder than it looks and most of the time I can't find anyting that i read before, because the only way to find anything is to go through links on the few pages that i've visited. A side bar with all the possible links would've been much more useful.<br />
4. What do I do next? <br />
   - [x] I need to refactor my JPS code, make diagrams like for the course Software Engineering, include more explanations, understand Tkinter better. I need to include the visualization for dijkstra asap and also include it in the GUI. I need to figure out the structure of my code, the responsibilities of each script, and how to divide the work between UI and the rest of src.<br /><br />

**Other considerations:** <br />
I spent around **18** hours this week working on the project. I don't know how it's possible. I suppose I'm just very ineffective<br />
 
