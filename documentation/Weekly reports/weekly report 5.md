# Weekly Report 5
1. What have I been up to this week? <br />
   - [x] I worked on a few features. I created a button for turning off making slides, and added time measuring for the algorithms. I found that actually most of the time is spent on initializing the algorithms, which distorted my first tests, but for making graphs I took that into account. I expanded the log to include time the algorithm takes to complete, the number of vertices, the number of edges, and the prediction made using the formulas in the implementation document. This way, I could collect the actual time performance of the algorithm and compare them to the formulas to see if my **time complexity** matches the one in specification document 
2. How has the program progressed? <br />
   - [x] The program measures time it takes the algorithm to complete, which is of course great
   - [x] I found an indirect way of measuring time complexity using the formulas in the implementation document.
   - [x] I added a lot of docstrings which hopefully make the purpose of each function clearer to the user
   - [x] I improved the efficiency of **JPS** by a lot. My implementation turns out ot be quite different from the original paper unfortunately, even though it leads to the same effects. I introduced a *pruning rule*: JPS stops scanning when the length of the scan is longer than the minimal distance found to the node. I simplified finding neighbours of the currently expanded node. I changed marking of the map to only occur when *visual mode* is on.
3. What did I learn this week / today? <br />
   - I learnt that I should pay more attention to the paper that I'm recreating the algorithm from. Too late I realized that my solution is quite different and much less efficient, and to fix it I need to do a lot of extra work.
   - Somehow it wasn't so clear to me before, but this week I realized that running Dijkstra in uniform grid is actually independent of where the start and goal coordinates are, because the algorithm needs to visit all the neighbouring nodes anyway.
   - I found that how well programmed an algorithm is really affects it's speed. At the beginning of the course I thought "JPS is so good compared to Dijkstra, there is no way that Dijkstra will outperform JPS in any scenario", even though comparing these two was the topic of my work. At this stage I know that my JPS is so poor it doesn't even finnish on graphs that take seconds for Dijkstra to solve. Also, since my JPS implementation prunes it's solution, it's speed generally depends mostly on the distance between start and goal nodes, which makes it hard to compare with Dijkstra. After all, if I choose (1,1) and (2,2) as start and goal coordinates, JPS will outperform Dijkstra because it will finish almost immediately, while Dijkstra will visit all the nodes on the map. On the other hand, if the start and goal coordinates are far away from each other, my JPS solution will take too long to run.
4. What was unclear or caused difficulties? Answer this section honestly, as you will receive help based on this section if needed.  <br />
   - Definitely an issue for me was that JPS underperformed by a lot. Because in this week I reviewed one other student's work, I realized that my implementation differed quite a lot from the one presented in JPS paper. My solution also uses a lot of overhead, e.g:
       - creating all 8 neighbour nodes for each node that is scanned, even when it's not necessary
       - Creating a node for **each** tile that is reached, which really wastes the principal way **JPS** outperforms other algorithms
   I think the major difficulty here is just the topic that I picked up and the fact that I didn't understand JPS enough. 
   - I am not sure what the *branching factor* is for JPS. I found papers online that said e.g. that for some version of JPS 5 is the default *branching factor*, and that an ideal JPS would have a *branching factor* of 1 as it would only expand the nodes it needs to. So my question is: is the branching factor dependent on the expanded nodes during the runtime, in which case I can measure it by calculating branching factor while running JPS, or is it just a constant (e.g. 8 because each node has 8 neighbours in a 2D grid that allows diagonal traversal). I'm just really not clear on this.
   - I realized that I'm totally in the blue about finding time complexity of my solution, and as I understand it, *I need* to find the achieved time complexities for this course. Because I could only find the worst case time complexity for JPS which is very, very high (it's exponential complexity *O(b^d)*), I don't think it's not realistic to compare any of my results to it. Also, because the complexity *O(b^d)* is dependent on two variables, to find it experimentally or to show that my program follows it I would need to run tests where *b* differs and *d* differs regardless of each other. But modifying *b* the *branching factor* is hard because (1) I don't completely understand it and (2) as I understand it it depends on the runtime? So there is not really a way to control *b* unless I use some more data science trick.
   - Similar issue with measuring time complexity of Dijkstra. Time complexity was very clear to me when I was doing e.g. programming for performance. It's also obvious for me how to show e.g. that a program is O(n^2). I could run it with a few different lenghts of input (values of *n*) and then graph them, and next to it draw a graph of y = x^2 and compare these two. But to find that complexity of my Dijkstra implementation really is O(V+E*log V) is a different question altogether. The approach that I thought of was to separately find the dependency on *E* the number of edges and *V* the number of vertices, but it sounds like a really hard task for this course. Firstly, because the number of edges and vertices dependent on each other a lot in a grid, and secondly because I would need to create maps that have those differences. 
4. What do I do next? <br />
   - I could work my implementation to resemble the JPS paper more, although it would be a lot of work and quite probably it would break all tests that I wrote. I'm not sure yet if I should do it or if I'll even have enough time before the end of the course.
   - My program has very deep recursion (or at least it appears to). Perhaps I can introduce more pruning rules or modify the solution in some other way
   - I could introduce other optimizations so that perhaps my version isn't so slow
   - I could ask the course assistants about investigating time complexity, I think I took a wrong approach entirely
**Other considerations:** <br />
I spent around **12** hours this week working on the project. I don't know how productive it was.<br />
 
